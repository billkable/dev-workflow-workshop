In this lesson you will review the initial commit in the codebase that
was generated by an *Accelerator*.

## What you will learn

By the end of this lesson,
you will be able to:

-   Describe what is an *Accelerator*.

-   Explain the benefits and tradeoffs of an *Accelerator*.

## Getting Started

Make sure you start in the codebase directory:

```terminal:execute-all
command: cd ~/tracker && clear
```

## Verify Build

Verify a local build succeeds:

```terminal:execute
command: ./gradlew clean build
```

## Review the Continuous Integration Pipeline

If you elected to configure a Github remote repository,
you will have a *Continuous Integration* automated build,
including unit and integration tests.

[Navigate to your github actions page](https://docs.github.com/en/actions/quickstart#viewing-your-workflow-results) for your tracker project.

You should see 1 workflow run named *accelerator-start* either in
progress,
or completed successfully.

The concept of *Accelerator* is that organizations may build templates
of common types of projects,
including source code, tests, pre-built automation,
and perhaps even bootstrap of environments.

The workshop only demonstrates up to Continuous Integration build
automation.
You will not see Continuous Delivery or Deployment pipelines,
although in real projects you will.

## Review the tracker project

Review the codebase under the `~/tracker` directory:

Open the codebase in your editor:

```dashboard:open-dashboard
name: Editor
```

## Build and Continuous Integration

1.  The project uses the [Gradle](https://gradle.org) build tool.

1.  Take a look at the `settings.gradle` file,
    you can see project name there:

    ```editor:select-matching-text
    file: ~/tracker/settings.gradle
    text: tracker
    ```

1.  Take a look at the project build file:

    ```editor:open-file
    file: ~/tracker/build.gradle
    ```

1.  You can see that the *Accelerator* uses spring boot version 2.5.2:

    ```editor:select-matching-text
    file: ~/tracker/build.gradle
    text: "id 'org.springframework.boot' version '2.5.2'"
    ```

1.  You can see the current project version is
    `v0`:

    ```editor:select-matching-text
    file: ~/tracker/build.gradle
    text: v0
    ```

1.  It also supplies the Spring Boot Starter dependencies that support:

    -   A blocking web application:

        ```editor:select-matching-text
        file: ~/tracker/build.gradle
        text: org.springframework.boot:spring-boot-starter-web
        ```

    -   Backed by H2 database:

        ```editor:select-matching-text
        file: ~/tracker/build.gradle
        text: com.h2database:h2
        ```

1.  Verify the Github Actions continuous integration automated build:

    ```editor:open-file
    file: ~/tracker/.github/workflows/pipeline.yml
    ```

1.  Notice that Github will listen for integrations to the remote `main`
    branch:

    ```editor:select-matching-text
    file: ~/tracker/.github/workflows/pipeline.yml
    text: "branches: [main]"
    ```

1.  Notice the pipeline will build the application,
    including compilation,
    test,
    and assembly of the Spring Boot Application via the gradle `build`
    task:

    ```editor:select-matching-text
    file: ~/tracker/.github/workflows/pipeline.yml
    text: "./gradlew"
    ```

    The Gradle wrapper script `gradlew` that is
    checked in with the codebase.

    It keeps parity with the developer workstation,
    as well as the automated Continuous Integration build.

## Review the Spring Boot Application

1.  Review the `TrackerApplication` class:

    ```editor:open-file
    file: ~/tracker/src/main/java/com/vmware/education/tracker/TrackerApplication.java
    ```

    This is the Spring Boot Application with the `main()` entry point
    for running your Spring Boot java application:

    ```editor:select-matching-text
    file: ~/tracker/src/main/java/com/vmware/education/tracker/TrackerApplication.java
    text: "public static void main(String[] args)"
    ```

1.  Review the `TrackerApplicationsTest` class:

    ```editor:open-file
    file: ~/tracker/src/test/java/com/vmware/education/tracker/TrackerApplicationTests.java
    ```

    This is the Spring Boot Integration test.
    The single `contextLoads()` test merely verifies the
    *Spring Application Context* is properly initialized when run.

    ```editor:select-matching-text
    file: ~/tracker/src/test/java/com/vmware/education/tracker/TrackerApplicationTests.java
    text: "public void contextLoads()"
    ```

1.  Notice there is no functional behavior in the codebase.
    It is a scaffold to build out a Spring Boot application.

1.  Verify the Spring Boot Application is enabled to test and run:

    ```terminal:execute
    command: ./gradlew clean build
    ```

    Notice this is the same command used by Github Actions Continuous
    Integration automated build.

## Benefits and Tradeoffs

Notice that you did not have build the application and pipeline from
scratch.

The *Accelerator* used to generate the project automated it for you:

-   Used the Spring Initializer to bootstrap the Spring Boot app
    codebase.
-   Generate a Github Actions Continuous Integration pipeline.
-   Tagged the initial version `v0` as the starting point you initially
    create your Github repository and project.

While the automation is good,
there are some tradeoffs to consider:

-   The developer is shielded from the details of the Spring project
    and its dependencies.
    You might also have dependencies provided to you transitively that
    you do not use.

-   You may be limited in the tools provided to you by the *Accelerator*.

As a mitigation to the tradeoffs,
take the time to understand what your *Accelerator* tools are doing,
and all the dependencies that are pulled into your application.

## Wrap

You can see that Accelerators can save you a lot of work:

- Boiler plate code
- Dependency resolution
- Automation

Developers should spend their time focusing on solving business problems,
and not so much on project set up or infrastructure concerns.
